<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css" integrity="sha512-G5951zOJGJPw43V0pp5ivIq4R7h2VRGan4XThJJkQ2JHGPew8NbMweLVeXfIh2W+n5EReQqPHpMEam68pT9qCg==" crossorigin="anonymous"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css" integrity="sha512-L7MWcK7FNPcwNqnLdZq86lTHYLdQqZaz5YcAgE+5cnGmlw8JT03QB2+oxL100UeB6RlzZLUxCGSS4/++mNZdxw==" crossorigin="anonymous"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.cat73.org",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言今天看到这么一个问题：FileReader是如何读取一个中文的,烦请大神分析一下?，于是写篇文章来分析一下 0.0  本回答仅对 Oracle JDK 1.8.0 负责。"><meta property="og:type" content="article"><meta property="og:title" content="FileReader 是如何读取中文的？"><meta property="og:url" content="https://blog.cat73.org/20160806/2016080601.FileReader-read/index.html"><meta property="og:site_name" content="Cat73 Blog"><meta property="og:description" content="前言今天看到这么一个问题：FileReader是如何读取一个中文的,烦请大神分析一下?，于是写篇文章来分析一下 0.0  本回答仅对 Oracle JDK 1.8.0 负责。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2016-08-06T11:57:41.000Z"><meta property="article:modified_time" content="2018-03-15T05:15:42.000Z"><meta property="article:author" content="Cat73"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://blog.cat73.org/20160806/2016080601.FileReader-read/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>FileReader 是如何读取中文的？ | Cat73 Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Cat73 Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">喵星人占领地球战略指挥部</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i> 分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i> 标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/Cat7373" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.cat73.org/20160806/2016080601.FileReader-read/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/upload/headimg.jpg"><meta itemprop="name" content="Cat73"><meta itemprop="description" content="大家好窝萌是来统治蓝星人和汪星人的喵星人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Cat73 Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> FileReader 是如何读取中文的？<a href="https://github.com/Cat7373/Blog/tree/src/source/_posts/2016080601.FileReader-read.md" class="post-edit-link" title="编辑" rel="noopener noreferrer" target="_blank"><i class="fa fa-pencil-alt"></i></a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2016-08-06 19:57:41" itemprop="dateCreated datePublished" datetime="2016-08-06T19:57:41+08:00">2016-08-06</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-03-15 13:15:42" itemprop="dateModified" datetime="2018-03-15T13:15:42+08:00">2018-03-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天看到这么一个问题：<code>FileReader是如何读取一个中文的,烦请大神分析一下?</code>，于是写篇文章来分析一下 0.0</p><blockquote><p>本回答仅对 Oracle JDK 1.8.0 负责。</p></blockquote><a id="more"></a><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>首先看一下<code>FileReader</code>的源代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.io.FileReader.java (已省略文档注释)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>{</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>{</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(FileDescriptor fd)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fd));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际看一下<code>FileReader</code>的源代码就会发现，它其实只是简单的包装了一下<code>InputStreamReader</code>，简单的帮你将文件转换成了<code>FileInputStream</code>传递给了<code>InputStreamReader</code>。<br>而中文其实就是一个<code>char</code>，那么问题实际上就是：<em><code>InputStreamReader</code>是如何读取<code>char</code>的</em>。</p><p>让我们来看一下<code>InputStreamReader</code>的<code>read</code>是怎么做的(只有<code>char[]</code>参数的<code>read</code>方法其实是包装了这个方法)：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int java.io.InputStreamReader.read(char, int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到它只是对<code>sd.read</code>的包装，那么我们再来看看这个<code>sd</code>是个什么鬼：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int java.io.InputStreamReader.java (已省略文档注释)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(in);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// ## check lock object</span></span><br><span class="line">    } <span class="keyword">catch</span> (UnsupportedEncodingException e) {</span><br><span class="line">        <span class="comment">// The default encoding should always be available</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>sd</code>是<code>StreamDecoder</code>的实例，顺便贴了被<code>FileReader</code>调用的构造函数，可以看到就是在这里实例化了<code>sd</code>。<br>那么我们再去瞅瞅这个<code>StreamDecoder.read</code>，这货是<code>sun</code>包的，没有直接提供源码。<br>但我们不怕，可以反编译，也可以看<code>OpenJDK</code>的代码，为了方便看，这里选择了看<code>OpenJDK</code>的代码。</p><h2 id="StreamDecoder"><a href="#StreamDecoder" class="headerlink" title="StreamDecoder"></a>StreamDecoder</h2><p>首先来看看它的<code>read</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">// 创建两个临时变量，避免直接修改参数</span></span><br><span class="line">    <span class="keyword">int</span> off = offset;</span><br><span class="line">    <span class="keyword">int</span> len = length;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) {</span><br><span class="line">        <span class="comment">// 检查自己是否已开启，如果没有则抛出异常</span></span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="comment">// 检查输出参数是否无效，无效则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> ((off < <span class="number">0</span>) || (off > cbuf.length) || (len < <span class="number">0</span>) ||</span><br><span class="line">            ((off + len) > cbuf.length) || ((off + len) < <span class="number">0</span>)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果读取长度为 0，则直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如上次读取的 2 个 byte 不是双字节字符，则这个值会被设置为 1 来防止返回值计算错误</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如上次读取的 2 个 byte 不是双字节字符</span></span><br><span class="line">        <span class="keyword">if</span> (haveLeftoverChar) {</span><br><span class="line">            <span class="comment">// 将上次读取的两个 byte 的后面的一个保存到返回值数组的第一个位置</span></span><br><span class="line">            <span class="comment">// Copy the leftover char into the buffer</span></span><br><span class="line">            cbuf[off] = leftoverChar;</span><br><span class="line">            <span class="comment">// 因为已经读取了一个字符，所以起始地址增加 1，长度减少 1</span></span><br><span class="line">            off++; len--;</span><br><span class="line">            <span class="comment">// 因为已经用过了上次读取的两个 byte 中后面的一个，所以上次取消设置这个标志位</span></span><br><span class="line">            haveLeftoverChar = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 已经读取了一个字符，将这个值设置为 1 来防止返回值计算错误</span></span><br><span class="line">            n = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果还需读取的长度为 0，或尚未准备好读取，则直接返回已读长度(1)</span></span><br><span class="line">            <span class="keyword">if</span> ((len == <span class="number">0</span>) || !implReady())</span><br><span class="line">                <span class="comment">// Return now if this is all we can produce w/o blocking</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还需读取的字符长度为 1</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 调用 read0 读取一个字符</span></span><br><span class="line">            <span class="comment">// Treat single-character array reads just like read()</span></span><br><span class="line">            <span class="keyword">int</span> c = read0();</span><br><span class="line">            <span class="comment">// 如果读取失败，则根据 n 的值确定返回失败还是 n</span></span><br><span class="line">            <span class="keyword">if</span> (c == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> (n == <span class="number">0</span>) ? -<span class="number">1</span> : n;</span><br><span class="line">            <span class="comment">// 保存读取到的字符</span></span><br><span class="line">            cbuf[off] = (<span class="keyword">char</span>)c;</span><br><span class="line">            <span class="comment">// 返回读取长度</span></span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 implRead 来读取更多字符</span></span><br><span class="line">        <span class="keyword">return</span> n + implRead(cbuf, off, off + len);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到前面都是针对单个字符的处理，实际读取多个字符的是后面的<code>implRead</code>，而之前也有个<code>read0</code>可以读取一个字符。<br>查看源代码发现，<code>read0</code>实际上还是对<code>read</code>的包装，最后还是会调用到<code>implRead</code>，所以就不浪费时间了，直接看<code>implRead</code>吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">implRead</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="comment">// 如果要读取的长度 <= 0，则抛出异常</span></span><br><span class="line">    <span class="comment">// In order to handle surrogate pairs, this method requires that</span></span><br><span class="line">    <span class="comment">// the invoker attempt to read at least two characters.  Saving the</span></span><br><span class="line">    <span class="comment">// extra character, if any, at a higher level is easier than trying</span></span><br><span class="line">    <span class="comment">// to deal with it here.</span></span><br><span class="line">    <span class="keyword">assert</span> (end - off > <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建保存结果的容器</span></span><br><span class="line">    CharBuffer cb = CharBuffer.wrap(cbuf, off, end - off);</span><br><span class="line">    <span class="keyword">if</span> (cb.position() != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// Ensure that cb[0] == cbuf[off]</span></span><br><span class="line">        cb = cb.slice();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经读到结尾的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> eof = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="comment">// 对输入缓冲区中的字符进行解码</span></span><br><span class="line">        CoderResult cr = decoder.decode(bb, cb, eof);</span><br><span class="line">        <span class="comment">// 如果是因为 Underflow 结束的解码</span></span><br><span class="line">        <span class="keyword">if</span> (cr.isUnderflow()) {</span><br><span class="line">            <span class="comment">// 如果已经读到结尾则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (eof)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果输出保存结果的容器已经没有剩余空间则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!cb.hasRemaining())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果已经读了一些数据，且尚未准备好继续读取，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> ((cb.position() > <span class="number">0</span>) && !inReady())</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">// Block at most once</span></span><br><span class="line">            <span class="comment">// 刷新输入缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> n = readBytes();</span><br><span class="line">            <span class="keyword">if</span> (n < <span class="number">0</span>) {</span><br><span class="line">                eof = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ((cb.position() == <span class="number">0</span>) && (!bb.hasRemaining()))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                decoder.reset();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果输出缓冲区没有更多的空间则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cr.isOverflow()) {</span><br><span class="line">            <span class="keyword">assert</span> cb.position() > <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        cr.throwException();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经读到结尾则重置解码器</span></span><br><span class="line">    <span class="keyword">if</span> (eof) {</span><br><span class="line">        <span class="comment">// ## Need to flush decoder</span></span><br><span class="line">        decoder.reset();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个字也没读出来，则返回读取失败</span></span><br><span class="line">    <span class="keyword">if</span> (cb.position() == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (eof)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回读取长度</span></span><br><span class="line">    <span class="keyword">return</span> cb.position();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，最关键的解码是由<code>decoder.decode</code>来完成的，那么这个<code>decoder</code>是啥呢，我们来瞅瞅：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CharsetDecoder decoder;</span><br><span class="line"></span><br><span class="line">StreamDecoder(InputStream in, Object lock, Charset cs) {</span><br><span class="line">    <span class="keyword">this</span>(in, lock, cs.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) {</span><br><span class="line">    <span class="keyword">super</span>(lock);</span><br><span class="line">    <span class="keyword">this</span>.cs = dec.charset();</span><br><span class="line">    <span class="keyword">this</span>.decoder = dec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This path disabled until direct buffers are faster</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span> && in <span class="keyword">instanceof</span> FileInputStream) {</span><br><span class="line">        ch = getChannel((FileInputStream)in);</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>)</span><br><span class="line">            bb = ByteBuffer.allocateDirect(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">this</span>.ch = <span class="keyword">null</span>;</span><br><span class="line">        bb = ByteBuffer.allocate(DEFAULT_BYTE_BUFFER_SIZE);</span><br><span class="line">    }</span><br><span class="line">    bb.flip();                      <span class="comment">// So that bb is initially empty</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过看源代码可以发现，这个东东是由构造函数去初始化的，回顾下<code>InputStreamReader</code>的构造函数，构造<code>StreamDecoder</code>的方法其实是这个：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>);</span><br></pre></td></tr></tbody></table></figure><p>OK，来瞅瞅这个<code>forInputStreamReader</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamDecoder <span class="title">forInputStreamReader</span><span class="params">(InputStream in, Object lock, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>{</span><br><span class="line">    String csn = charsetName;</span><br><span class="line">    <span class="keyword">if</span> (csn == <span class="keyword">null</span>)</span><br><span class="line">        csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (Charset.isSupported(csn))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamDecoder(in, lock, Charset.forName(csn));</span><br><span class="line">    } <span class="keyword">catch</span> (IllegalCharsetNameException x) { }</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException (csn);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>charsetName</code>参数传进来的就是<code>null</code>，所以实际会取<code>Charset.defaultCharset().name()</code>。<br>查看源码可知，这个编码默认是<code>System.getProperty("file.encoding")</code>，如不支持则会使用<code>UTF-8</code>。<br>这里我就不再去分析<code>Charset.newDecoder</code>的做了什么了，直接拿一段简单的代码执行一下就知道了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Charset.defaultCharset().newDecoder().getClass());</span><br><span class="line"><span class="comment">// Windows10x64 中文版 未改动任何参数 默认编码 GBK</span></span><br><span class="line"><span class="comment">// 输出：class sun.nio.cs.ext.DoubleByte$Decoder</span></span><br></pre></td></tr></tbody></table></figure><p>OK，现在我们知道了，解码工作实际是由<code>sun.nio.cs.ext.DoubleByte$Decoder</code>来完成的。<br>这个类里面实现了对双字节字符的解码，这个我就不写了，有兴趣可以自己去瞅瞅：<br><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/nio/cs/ext/DoubleByte.java#l111" target="_blank" rel="noopener noreferrer">sun.nio.cs.ext.DoubleByte$Decoder</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>FileReader</code>是通过<code>System.getProperty("file.encoding")</code>对应的解码器来读取中文的。</p><h2 id="链接-amp-参考"><a href="#链接-amp-参考" class="headerlink" title="链接 & 参考"></a>链接 & 参考</h2><ul><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/nio/cs/StreamDecoder.java" target="_blank" rel="noopener noreferrer">StreamDecoder.java</a></li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Java/" rel="tag"># Java</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20160805/2016080501.next-highlight-langs/" rel="prev" title="NexT 自带的语法高亮插件支持的语言列表"><i class="fa fa-chevron-left"></i> NexT 自带的语法高亮插件支持的语言列表</a></div><div class="post-nav-item"> <a href="/20170716/2017071601.https/" rel="next" title="用 Let’s Encrypt 免费证书开启 HTTPS 并获得 ssllabs 满分的过程">用 Let’s Encrypt 免费证书开启 HTTPS 并获得 ssllabs 满分的过程<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初步分析"><span class="nav-number">2.</span> <span class="nav-text">初步分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StreamDecoder"><span class="nav-number">3.</span> <span class="nav-text">StreamDecoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论"><span class="nav-number">4.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接-amp-参考"><span class="nav-number">5.</span> <span class="nav-text">链接 & 参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Cat73" src="/upload/headimg.jpg"><p class="site-author-name" itemprop="name">Cat73</p><div class="site-description" itemprop="description">大家好窝萌是来统治蓝星人和汪星人的喵星人</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">20</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Cat7373" title="Github → https://github.com/Cat7373" rel="noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i> Github</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://notes.jimliang.com/" title="http://notes.jimliang.com/" rel="noopener noreferrer" target="_blank">Jim's Notes</a></li><li class="links-of-blogroll-item"> <a href="https://www.locsian.com/" title="https://www.locsian.com" rel="noopener noreferrer" target="_blank">Locsian's Blog</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> © 2016 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Cat73</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener noreferrer" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js" integrity="sha512-PtERWMgvZ4H5VEu6gEcSap5qoi/OQksnTw+B4/0wyPrCe7Lbz1tl3piTtuNcOCV5OEXFFePqVTJW3h9Aacj2sA==" crossorigin="anonymous"></script><script src="/lib/velocity/velocity.min.js" integrity="sha512-r+WC4s/o+ePgGesrHDTOQpOHFMQH39icY2OUcaUU6SrFbi1keeuy3jHq8Q0SIuACtfZ7zRfPWYt0huP/guuU2w==" crossorigin="anonymous"></script><script src="/lib/velocity/velocity.ui.min.js" integrity="sha512-48rakD7aXAKjynjPfmdjgeHrLZcVimYHIq4hS4emn7MMLhfcpS5Mt4Mn3HeCr4vMGKUKgfoZ++ceCeR6UAKhWA==" crossorigin="anonymous"></script><script src="/js/utils.js" integrity="sha512-xlafgwhcUyEE7HKDpyNDzbdm7SXcIlSGFmOWE2dm+fd8ZRANLYNFJLFjWSEXt14bKbfWMsfx3ibJcljCQcCE2Q==" crossorigin="anonymous"></script><script src="/js/motion.js" integrity="sha512-aFZpRY3gmkyHYWIlJD7wZs2wzIAIqwSazgtis0Va5rGJZdj7QwXfYqdlb3LBARYJF4TTN0+O1BVAnJ6vTTob/A==" crossorigin="anonymous"></script><script src="/js/schemes/pisces.js" integrity="sha512-A2xN5D3dzTOGw6kMAcQxECrxdn/LqzrehzaNQvm1n/06t91TyvJ85eXkBhaV5XelEmMVEFYkGPaKtkGRm4YuPQ==" crossorigin="anonymous"></script><script src="/js/next-boot.js" integrity="sha512-zv9gPg6GY1OHOqhAqp2NTAf+UOMVCD++HCRqoKgfhhKi7R5Rsy7V13qKbd+ibbhkqYP5xQEvyW9L7W3hGw7juA==" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7e893f940e4723d2af60',
      clientSecret: 'b5336eb0b13e2b09d26bc6f7fc84752c7c104db3',
      repo        : 'Blog',
      owner       : 'Cat7373',
      admin       : ['Cat7373'],
      id          : '2b522a9637d2c84c67f410b2365a531e',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>