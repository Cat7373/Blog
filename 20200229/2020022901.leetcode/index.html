<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css" integrity="sha512-UINwzdWNTVVDwYuInGcoEqJBL0DRq3IHnIuf+vp29FsSxKCexm2oETkiBvzpodzsLijWUz19/5eHS2pOukcg2A==" crossorigin="anonymous"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"blog.cat73.org",root:"/",scheme:"Gemini",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言此文章用于在阅读labuladong的算法小抄时记录笔记，未来可能也会用于其它算法和数据结构方面学习的笔记"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode 刷题笔记"><meta property="og:url" content="https://blog.cat73.org/20200229/2020022901.leetcode/index.html"><meta property="og:site_name" content="Cat73 Blog"><meta property="og:description" content="前言此文章用于在阅读labuladong的算法小抄时记录笔记，未来可能也会用于其它算法和数据结构方面学习的笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.cat73.org/upload/leetcode_00001.png"><meta property="article:published_time" content="2020-02-29T11:13:00.000Z"><meta property="article:modified_time" content="2020-03-02T06:13:01.497Z"><meta property="article:author" content="Cat73"><meta property="article:tag" content="LeetCode"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.cat73.org/upload/leetcode_00001.png"><link rel="canonical" href="https://blog.cat73.org/20200229/2020022901.leetcode/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>LeetCode 刷题笔记 | Cat73 Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Cat73 Blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">喵星人占领地球战略指挥部</h1></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/Cat7373" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.cat73.org/20200229/2020022901.leetcode/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/upload/headimg.jpg"><meta itemprop="name" content="Cat73"><meta itemprop="description" content="大家好窝萌是来统治蓝星人和汪星人的喵星人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Cat73 Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> LeetCode 刷题笔记<a href="https://github.com/Cat7373/Blog/tree/src/source/_posts/2020022901.leetcode.md" class="post-edit-link" title="编辑" rel="noopener noreferrer" target="_blank"><i class="fa fa-pencil"></i></a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-29 19:13:00" itemprop="dateCreated datePublished" datetime="2020-02-29T19:13:00+08:00">2020-02-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-03-02 14:13:01" itemprop="dateModified" datetime="2020-03-02T14:13:01+08:00">2020-03-02</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文章用于在阅读<a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener noreferrer">labuladong的算法小抄</a>时记录笔记，未来可能也会用于其它算法和数据结构方面学习的笔记</p><a id="more"></a><blockquote><p>文中实例代码由<code>Java</code>或<code>Kotlin</code>编写，其中，原文中的代码可能会直接 copy 或转为<code>Java</code>后 copy 过来，我自己写的代码多为<code>Kotlin</code></p></blockquote><h1 id="第零章-必读"><a href="#第零章-必读" class="headerlink" title="第零章 必读"></a>第零章 必读</h1><h2 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h2><p>计算机中，数据结构只有两种：数组（顺序存储）和链表（链式存储）</p><p>其它数据结构均是由这两种结构进行组合得来</p><p>队列和栈既可以使用数组也可以使用链表来实现，数组需要考虑扩容问题；链表则不用，但需要更多空间存储指针</p><p>图也可以用这两种结构来表示，邻接表是链表，邻接矩阵就是而为数组，邻接矩阵判断连通性迅速，但用于存储稀疏图会浪费空间；邻接表比较节省空间，但操作效率比邻接矩阵要低</p><p>散列(Hash)表是通过散列函数将键映射到一个大数组里，对于散列冲突，拉链法会通过链表依次存储同散列的键(如 Java 的 HashMap)，线性探查法会存到后面的空位上，不需要指针存储空间，但操作稍微复杂</p><p>树，用数组实现就是堆，因为堆是一个完全二叉树；用链表实现就是常见的树，不一定是完全二叉树，在基于链表的树的结构之上，又衍生出各种设计，如：二叉搜索树、AVL 树、红黑树、区间树、B 树等等，对应解决不同问题</p><p>数组是紧凑连续的存储结构，可以随机访问，且较节约存储空间；但如果内存一次没分配够，需要进行扩容，就需要分配一块更大的空间，将数据全部 copy 过去，时间复杂度 O(N)；如果你想在数组中间插入或删除，就必须移动后面的数据以保持连续，时间复杂度也是 O(N)</p><p>链表元素并不连续，是靠指针指向下一个元素的位置的，因此不存在扩容问题；如果知道某一个元素的先驱和后驱，操作指针即可删除或插入新元素，时间复杂度 O(1)，但正因为存储空间不连续，因此不能随机访问，而且由于需要存储指针，因此会相对消耗更多存储空间</p><h2 id="数据结构的基本操作"><a href="#数据结构的基本操作" class="headerlink" title="数据结构的基本操作"></a>数据结构的基本操作</h2><p>对任何数据结构，其基本操作无非是遍历 + 访问，具体一点就是增删改查</p><p>数据结构种类很多，但他们的目的都是在不同场景下，尽可能高效的进行增删改查</p><p>数据访问常见的几种框架：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组遍历结构，典型的线性迭代结构</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < arr.length; i++) {</span><br><span class="line">        <span class="comment">// 访问 arr[i]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表遍历框架</span></span><br><span class="line"><span class="comment">/** 基本单链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val,</span><br><span class="line">    Node next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) {</span><br><span class="line">        <span class="comment">// 访问 p.val</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node head)</span> </span>{</span><br><span class="line">    <span class="comment">// 访问 head.val</span></span><br><span class="line">    <span class="keyword">if</span> (head.next != <span class="keyword">null</span>) {</span><br><span class="line">        traverse(head.next)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树遍历框架，典型的非线性递归遍历结构</span></span><br><span class="line"><span class="comment">/** 基本的二叉树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left, right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="comment">// 访问 root.val</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) {</span><br><span class="line">        traverse(root.left)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) {</span><br><span class="line">        traverse(root.right)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N 叉树遍历</span></span><br><span class="line"><span class="comment">/** N 叉树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node[] children;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="comment">// 访问 root.val</span></span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) {</span><br><span class="line">        traverse(child)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="第一章-动态规划"><a href="#第一章-动态规划" class="headerlink" title="第一章 动态规划"></a>第一章 动态规划</h1><p>动态规划问题一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如求最长递增子序列、最小编辑距离等</p><p>既然是求最值，核心问题是什么呢？核心问题就是穷举。因为要求最值，就要把所有可行的答案穷举处理啊，然后在其中找最值</p><p>动态规划的穷举有些特别，这类问题存在<code>重叠子问题</code>，如果暴力穷举的话效率会很低，所以需要<code>备忘录</code>或<code>DP table</code>来优化穷举过程，避免不必要的计算</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但问题可以千变万化，穷举所有可行解并不是一件容易的事，只有列出正确的<code>状态转移方程</code>才能正确的穷举</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><blockquote><p>尽管这个列子严格来说并不是动态规划问题，但可助于理解重叠子问题</p></blockquote><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>斐波那契数列的数学形式递归是这样的：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span>(n) {</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span> -> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> -> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>学校老师讲递归的时候经常会拿这个举例，虽然这样的代码简洁易懂，但十分低效，比如想要计算 f(20)，就得先计算 f(19) 和 f(18)，然后要计算 f(19)，就要先计算 f(18) 和 f(17)，以此类推，最后到 f(1) 或 f(2) 时，结果已知，就能直接返回结果，递归树就不再向下生长了</p><p>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间</p><p>子问题个数，显然次问题中为指数级别，子问题个数为 O(2^n)</p><p>解决一个子问题需要的时间，由于本算法没有循环，只有一个加法操作，时间为 O(1)</p><p>所以这个算法的时间复杂度为 O(2^n)，指数级别，爆炸</p><p>观察递归流程，很明显可以发现算法低效的原因：存在大量重复计算，如 f(18) 被计算了两次，而且由于 f(18) 的子问题体量巨大，多算一遍会耗费巨大的时间。更何况，还不止 f(18) 这一个问题被重复计算，所以这个算法及其低效</p><p>这就是动态规划问题的第一个性质：重叠子问题</p><h3 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h3><p>既然耗时的原因是重复计算，那么我们可以造一个<code>备忘录</code>，每次算出某个子问题的答案后先记到备忘录里再返回，每次遇到一个子问题先去<code>备忘录</code>查一查，如果发现问题已经被解决过，拿就把答案直接拿出来用，不要再重复计算一次了。</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span> = fibHelper(IntArray(n), n) <span class="comment">// 初始化一个备忘录，转给 helper 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibHelper</span><span class="params">(memo: <span class="type">IntArray</span>, n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span>(n) {</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span> -> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> -> {</span><br><span class="line">        <span class="keyword">var</span> v = memo[n - <span class="number">1</span>] <span class="comment">// 取出备忘录中的结果</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="number">0</span>) {</span><br><span class="line">            v <span class="comment">// 已经计算过</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 进行计算</span></span><br><span class="line">            v = fibHelper(memo, n - <span class="number">1</span>) + fibHelper(memo, n - <span class="number">2</span>)</span><br><span class="line">            memo[n - <span class="number">1</span>] = v <span class="comment">// 保存到备忘录中</span></span><br><span class="line">            v <span class="comment">// 返回结果</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样，每个子问题就只会被计算一次，第二次就可以直接从<code>备忘录</code>中获取结果，实际上，带<code>备忘录</code>的递归算法，把一棵存在巨量冗余的递归树通过<code>剪枝</code>，改造成了一副不存在冗余的递归图，极大的减少了子问题的个数</p><p>递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间</p><p>子问题个数，由于本算法不存在冗余计算，子问题就是 f(1)、f(2)、f(3) … f(19)、f(20)，数量与输入规模 n = 20 成正比，所以子问题个数为 O(n)</p><p>解决一个子问题的时间，同上，没什么循环，因此为 O(1)</p><p>所以，本算法的时间复杂度为 O(n)，对比暴力递归的 O(2^n)，简直是降维打击</p><p>实际上，这种解法的效率和迭代的动态规划已经差不多了，只不过这种方法叫<code>自顶向下</code>，动态规划叫做<code>自底向上</code></p><p>自顶向下是指从一个规模较大的问题如 f(20) 向下逐渐分解规模，直到 f(1)、f(2) 触底，然后逐层返回答案</p><p>自底向上是指，我们从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路</p><h3 id="dp-数组的迭代解法"><a href="#dp-数组的迭代解法" class="headerlink" title="dp 数组的迭代解法"></a>dp 数组的迭代解法</h3><p>有了上一步的启发，我们可以把这个<code>备忘录</code>独立出来成为一张表，就叫<code>DP table</code>吧，在这张表上完成<code>自底向上</code>的推算</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(n)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2</span> until n) {</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你会发现这个<code>DP table</code>特别像之前那个剪枝后的结果，只是反过来算而已。实际上，带<code>备忘录</code>的递归解法终端鹅备忘录，最终完成后就是这个<code>DP tabel</code>，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同</p><p>这里，引出<code>状态转移方程这个名词</code>，实际上就是描述问题结构的数学形式：</p><p><img src="/upload/leetcode_00001.png" alt></p><p>你会发现，上面几种解法的所有操作，例如<code>f(n - 1) + f(n - 2)</code>、<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，其实都是围绕这个方程式的不同表现形式，可见列出<code>状态转移方程</code>的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法</p><p>千万不要看不起暴力解，动态规划问题最困难的就是列出<code>状态转移方程</code>，即这个暴力解，优化方法无非是用<code>备忘录</code>或<code>DP table</code>，再无奥妙可言</p><p>最后，其实根据斐波那契数列的状态转移方程，当前状态只与前两个状态有关，所以其实并不需要那么长的一个<code>DP table</code>来存储所有的状态，只要想办法存储之前的两个状态就行了，所以，可以进一步优化，将空间复杂度降为 O(1)</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fib</span><span class="params">(n: <span class="type">Int</span>)</span></span> = <span class="keyword">when</span>(n) {</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span> -> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> -> {</span><br><span class="line">        <span class="keyword">var</span> prev = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> curr = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3</span>..n) {</span><br><span class="line">            <span class="keyword">val</span> sum = prev + curr</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = sum</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curr</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h2><blockquote><p>给你<code>k</code>种面值的硬币，面值分别为<code>c1, c2, ..., ck</code>，每种硬币数量无限，再给一个总金额<code>amount</code>，求出最少需要几枚硬币才能凑出这个金额，如果不能凑出，应返回 -1</p></blockquote><p>首先，这个问题是动态规划问题，因为它具有<code>最优子结构</code>。要符合<code>最优子结构</code>，子问题间必须相互独立，比如，你的原问题是考出最高总成绩，那么你的子问题就是把语文考到最高、数学考到最高… 为了每门课考到最高，你要把每门课的选择题分数拿到最高，填空题分数拿到最高… 当然，最终就是你每门课都是满分，这就是最高的总成绩</p><p>最高的总成绩就是总分，这个过程符合<code>最优子结构</code>，每门课考到最高这些子问题是互相独立，互不干扰的</p><p>回到凑零钱问题，比如你想求<code>amount = 11</code>时的最少硬币数（原问题），在尝试面值为<code>1</code>的硬币时，只需要将<code>amount = 10</code>的最少硬币数加 1 即可，同理，尝试面值为<code>5</code>的硬币时，只需要将<code>amount = 6</code>的最少硬币数加 1。因为硬币的数量是没有限制的，子问题之间没有相互制衡，是相互独立的</p><h3 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>那么，既然这是一个动态规划问题，要如何列出正确的状态转移方程呢？</p><p>先确定状态，也就是原问题和子问题中变化的量，由于硬币数量是无限的，所以唯一的状态就是目标金额<code>amount</code></p><p>然后确定<code>dp</code>函数定义：对于目标金额<code>n</code>，至少需要<code>dp(n)</code>个硬币凑出该金额</p><p>然后确定<code>选择</code>并择优，也就是对于每个状态，可以作出什么选择来改变当前状态。具体到这个问题，无论当前的目标金额是多少，选择就是从面值列表<code>coins</code>中选择一个硬币，然后目标金额会减少</p><p>最后明确<code>base case</code>，显然目标金额为 0 时，所需的硬币数量为 0；当目标金额小于 0 时，无解，返回 -1</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dp</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n < <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">// 求最小值</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) {</span><br><span class="line">            <span class="keyword">val</span> subProblem = dp(n - coin)</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (subProblem < <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">            res = min(res, subProblem + <span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (res == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> res</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，状态转移方程其实已经完成了，上面的算法已经是暴力解法了，只不过需要消除一下重叠问题</p><p>分析一下时间复杂度，子问题个数为<code>O(n ^ k)</code>，问题中有一个循环，复杂度为<code>O(k)</code>，因此算法的复杂度为<code>O(k * n^k)</code></p><h3 id="带备忘录的递归-1"><a href="#带备忘录的递归-1" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h3><p>只需要稍加修改，就可以通过添加备忘录来消除重叠问题：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">coinChange</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">val</span> memo = mutableMapOf<<span class="built_in">Int</span>, <span class="built_in">Int</span>>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dp</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">        <span class="comment">// 通过查询备忘录避免重复计算</span></span><br><span class="line">        <span class="keyword">val</span> c = memo[n]</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (n < <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">// 求最小值</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) {</span><br><span class="line">            <span class="keyword">val</span> subProblem = dp(n - coin)</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (subProblem < <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">            res = min(res, subProblem + <span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">        res = <span class="keyword">if</span> (res == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> res</span><br><span class="line">        memo[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>显然，备忘录大大减少了子问题的数量，完全消除了子问题冗余，所以子问题数量不会超过总金额<code>n</code>，即子问题数量为<code>O(n)</code>，处理一个子问题的时间不变，仍然是<code>O(k)</code>，因此时间复杂度为<code>O(kn)</code></p><h3 id="dp-数组的迭代解法-1"><a href="#dp-数组的迭代解法-1" class="headerlink" title="dp 数组的迭代解法"></a>dp 数组的迭代解法</h3><p>通过<code>DP table</code>也可以消除重叠子问题，<code>dp</code>数组和刚刚的<code>dp</code>汉东湖定义类似：</p><p><code>dp[i] = x</code>表示，当目标金额为<code>i</code>时，至少需要<code>x</code>枚硬币</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">coinChange3</span><span class="params">(coins: <span class="type">IntArray</span>, amount: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">val</span> dp = IntArray(amount + <span class="number">1</span>) { <span class="built_in">Int</span>.MAX_VALUE }</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个 amount 需要的最少硬币数</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..amount) {</span><br><span class="line">        <span class="comment">// 求在选择每个硬币时，所需的最少硬币数</span></span><br><span class="line">        <span class="keyword">for</span> (coin <span class="keyword">in</span> coins) {</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin < <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 查 DP table</span></span><br><span class="line">            <span class="keyword">val</span> c = dp[i - coin]</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="built_in">Int</span>.MAX_VALUE) <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 计算最少硬币数</span></span><br><span class="line">            dp[i] = min(dp[i], c + <span class="number">1</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (dp[amount] == <span class="built_in">Int</span>.MAX_VALUE) -<span class="number">1</span> <span class="keyword">else</span> dp[amount]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此算法的子问题数量和计算一个子问题的复杂度均和上个算法相同，时间复杂度为<code>O(kn)</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>计算机解决问题其实没有任何奇淫技巧，它唯一的解决方法就是穷举，穷举所有可能性。算法设计无非就是先思考<code>如何穷举</code>，然后再追求<code>如何聪明的穷举</code></p><p>列出状态转移方程，就是在解决<code>如何穷举</code>的问题；备忘录、DP table 就是在追求<code>如何聪明的穷举</code>；用空间换时间的思路，是降低时间复杂度的不二法门</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/LeetCode/" rel="tag"># LeetCode</a></div><div class="post-nav"><div class="post-nav-item"><a href="/20200115/2020011501.vue-learn/" rel="prev" title="Vue 学习笔记"><i class="fa fa-chevron-left"></i> Vue 学习笔记</a></div><div class="post-nav-item"></div></div></footer></article></div></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第零章-必读"><span class="nav-number">2.</span> <span class="nav-text">第零章 必读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构的存储方式"><span class="nav-number">2.1.</span> <span class="nav-text">数据结构的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构的基本操作"><span class="nav-number">2.2.</span> <span class="nav-text">数据结构的基本操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-动态规划"><span class="nav-number">3.</span> <span class="nav-text">第一章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#斐波那契数列"><span class="nav-number">3.1.</span> <span class="nav-text">斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力递归"><span class="nav-number">3.1.1.</span> <span class="nav-text">暴力递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带备忘录的递归"><span class="nav-number">3.1.2.</span> <span class="nav-text">带备忘录的递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dp-数组的迭代解法"><span class="nav-number">3.1.3.</span> <span class="nav-text">dp 数组的迭代解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#凑零钱问题"><span class="nav-number">3.2.</span> <span class="nav-text">凑零钱问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#暴力递归-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">暴力递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带备忘录的递归-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">带备忘录的递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dp-数组的迭代解法-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">dp 数组的迭代解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="Cat73" src="/upload/headimg.jpg"><p class="site-author-name" itemprop="name">Cat73</p><div class="site-description" itemprop="description">大家好窝萌是来统治蓝星人和汪星人的喵星人</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Cat7373" title="Github → https://github.com/Cat7373" rel="noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i> Github</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://notes.jimliang.com/" title="http://notes.jimliang.com/" rel="noopener noreferrer" target="_blank">Jim's Notes</a></li><li class="links-of-blogroll-item"> <a href="https://www.locsian.com/" title="https://www.locsian.com" rel="noopener noreferrer" target="_blank">Locsian's Blog</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> © 2016 – <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Cat73</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener noreferrer" target="_blank">Hexo</a> 强力驱动 v4.2.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener noreferrer" target="_blank">NexT.Gemini</a> v7.7.2</div></div></footer></div><script src="/lib/anime.min.js" integrity="sha512-PtERWMgvZ4H5VEu6gEcSap5qoi/OQksnTw+B4/0wyPrCe7Lbz1tl3piTtuNcOCV5OEXFFePqVTJW3h9Aacj2sA==" crossorigin="anonymous"></script><script src="/lib/velocity/velocity.min.js" integrity="sha512-r+WC4s/o+ePgGesrHDTOQpOHFMQH39icY2OUcaUU6SrFbi1keeuy3jHq8Q0SIuACtfZ7zRfPWYt0huP/guuU2w==" crossorigin="anonymous"></script><script src="/lib/velocity/velocity.ui.min.js" integrity="sha512-48rakD7aXAKjynjPfmdjgeHrLZcVimYHIq4hS4emn7MMLhfcpS5Mt4Mn3HeCr4vMGKUKgfoZ++ceCeR6UAKhWA==" crossorigin="anonymous"></script><script src="/js/utils.js" integrity="sha512-ATLIzNav5FRMiIJqz1uOJghf0AAdcDC88TsD96yiqUkr/XVW1/LnsFY5v+e+wBsJuDfCn4a71wjWzKSl4zjtaQ==" crossorigin="anonymous"></script><script src="/js/motion.js" integrity="sha512-aFZpRY3gmkyHYWIlJD7wZs2wzIAIqwSazgtis0Va5rGJZdj7QwXfYqdlb3LBARYJF4TTN0+O1BVAnJ6vTTob/A==" crossorigin="anonymous"></script><script src="/js/schemes/pisces.js" integrity="sha512-ZrPCeh61SBfbxk9FytgklTZ1vhsEOu7OB/P15bVneMo+nBfdDF9Kuu1SCKDsyTYWI9HppjbnFa67ENpSgKnn9g==" crossorigin="anonymous"></script><script src="/js/next-boot.js" integrity="sha512-G5gtuvfl7lpROrTWSoDTehItepHuuNT0olzKmoR7+WDn1I6xsWwyqAxwT+7TgcbiWZ7s2TlHq5PfUrVs7GoQ5w==" crossorigin="anonymous"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7e893f940e4723d2af60',
      clientSecret: 'b5336eb0b13e2b09d26bc6f7fc84752c7c104db3',
      repo        : 'Blog',
      owner       : 'Cat7373',
      admin       : ['Cat7373'],
      id          : 'e48f0ebd6a709fe98cf02136884d03d6',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>